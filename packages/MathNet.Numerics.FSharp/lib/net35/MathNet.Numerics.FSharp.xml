<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>MathNet.Numerics.FSharp</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:MathNet.Numerics.Compatibility">

</member>
<member name="M:MathNet.Numerics.Complex32Module.acsch(MathNet.Numerics.Complex32)">
<summary>
 Inverse Hyperbolic Cosecant
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.asech(MathNet.Numerics.Complex32)">
<summary>
 Inverse Hyperbolic Secant
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.acoth(MathNet.Numerics.Complex32)">
<summary>
 Inverse Hyperbolic Cotangent
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.atanh(MathNet.Numerics.Complex32)">
<summary>
 Inverse Hyperbolic Tangent
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.acosh(MathNet.Numerics.Complex32)">
<summary>
 Inverse Hyperbolic Cosine
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.asinh(MathNet.Numerics.Complex32)">
<summary>
 Inverse Hyperbolic Sine
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.csch(MathNet.Numerics.Complex32)">
<summary>
 Hyperbolic Cosecant
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.sech(MathNet.Numerics.Complex32)">
<summary>
 Hyperbolic Secant
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.coth(MathNet.Numerics.Complex32)">
<summary>
 Hyperbolic Cotangent
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.tanh(MathNet.Numerics.Complex32)">
<summary>
 Hyperbolic Tangent
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.cosh(MathNet.Numerics.Complex32)">
<summary>
 Hyperbolic Cosine
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.sinh(MathNet.Numerics.Complex32)">
<summary>
 Hyperbolic Sine
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.acsc(MathNet.Numerics.Complex32)">
<summary>
 Arc Cosecant
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.asec(MathNet.Numerics.Complex32)">
<summary>
 Arc Secant
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.acot(MathNet.Numerics.Complex32)">
<summary>
 Arc Cotangent
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.atan(MathNet.Numerics.Complex32)">
<summary>
 Arc Tangent
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.acos(MathNet.Numerics.Complex32)">
<summary>
 Arc Cosine
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.asin(MathNet.Numerics.Complex32)">
<summary>
 Arc Sine
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.csc(MathNet.Numerics.Complex32)">
<summary>
 Cosecant
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.sec(MathNet.Numerics.Complex32)">
<summary>
 Secant
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.cot(MathNet.Numerics.Complex32)">
<summary>
 Cotangent
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.tan(MathNet.Numerics.Complex32)">
<summary>
 Tangent
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.cos(MathNet.Numerics.Complex32)">
<summary>
 Cosine
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.sin(MathNet.Numerics.Complex32)">
<summary>
 Sine
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.sqrt(MathNet.Numerics.Complex32)">
<summary>
 sqrt(x) and 0 &lt;= phase(x) &lt; pi
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.sqr(MathNet.Numerics.Complex32)">
<summary>
 sqr(x) is the square (power 2)
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.powf(System.Single,MathNet.Numerics.Complex32)">
<summary>
 pow(power,x) is the scalar power
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.pow(MathNet.Numerics.Complex32,MathNet.Numerics.Complex32)">
<summary>
 pow(power,x) is the complex power
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.log(System.Single,MathNet.Numerics.Complex32)">
<summary>
 log(base,x) is log with custom base
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.log10(MathNet.Numerics.Complex32)">
<summary>
 log10(x) is common log (base 10)
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.ln(MathNet.Numerics.Complex32)">
<summary>
 ln(x) is natural log (base e)
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.exp(MathNet.Numerics.Complex32)">
<summary>
 exp(x) = e^x
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.muls(MathNet.Numerics.Complex32,System.Single)">
<summary>
 Multiply a complex number by a scalar
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.smul(System.Single,MathNet.Numerics.Complex32)">
<summary>
 Multiply a scalar by a complex number
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.div(MathNet.Numerics.Complex32,MathNet.Numerics.Complex32)">
<summary>
 Complex division of two complex numbers
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.mul(MathNet.Numerics.Complex32,MathNet.Numerics.Complex32)">
<summary>
 Multiply two complex numbers
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.sub(MathNet.Numerics.Complex32,MathNet.Numerics.Complex32)">
<summary>
 Subtract one complex number from another
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.add(MathNet.Numerics.Complex32,MathNet.Numerics.Complex32)">
<summary>
 Add two complex numbers
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.conjugate(MathNet.Numerics.Complex32)">
<summary>
 The conjugate of a complex number, i.e. x-yi
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.neg(MathNet.Numerics.Complex32)">
<summary>
 Unary negation of a complex number
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.phase(MathNet.Numerics.Complex32)">
<summary>
 The polar-coordinate phase of a complex number
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.magnitude(MathNet.Numerics.Complex32)">
<summary>
 The polar-coordinate magnitude of a complex number
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.imagPart(MathNet.Numerics.Complex32)">
<summary>
 The imaginary part of a complex number
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.realPart(MathNet.Numerics.Complex32)">
<summary>
 The real part of a complex number
</summary>
</member>
<member name="P:MathNet.Numerics.Complex32Module.pi">
<summary>
 pi
</summary>
</member>
<member name="P:MathNet.Numerics.Complex32Module.onei">
<summary>
 The complex number 0+1i
</summary>
</member>
<member name="P:MathNet.Numerics.Complex32Module.one">
<summary>
 The complex number 1+0i
</summary>
</member>
<member name="P:MathNet.Numerics.Complex32Module.zero">
<summary>
 The complex number 0+0i
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Complex32Module.cis(System.Single)">
<summary>
 A complex of magnitude 1 and the given phase and , i.e. cis x = mkPolar 1.0 x
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.mkPolar(System.Single,System.Single)">
<summary>
 Create a complex number using magnitude/phase polar coordinates
</summary>
</member>
<member name="M:MathNet.Numerics.Complex32Module.mkRect(System.Single,System.Single)">
<summary>
 Create a complex number using real and imaginary parts
</summary>
</member>
<member name="T:MathNet.Numerics.Complex32Module">

</member>
<member name="M:MathNet.Numerics.ComplexExtensions.Complex32.CreatePolar.Static(System.Single,System.Single)">
<summary>
 Create a complex number using magnitude/phase polar coordinates
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexExtensions.Complex32.Create.Static(System.Single,System.Single)">
<summary>
 Create a complex number x+ij using rectangular coordinates
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexExtensions.Complex32.get_i(MathNet.Numerics.Complex32)">
<summary>
 The imaginary part of a complex number
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexExtensions.Complex32.get_r(MathNet.Numerics.Complex32)">
<summary>
 The real part of a complex number
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexExtensions.Complex.CreatePolar.Static(System.Double,System.Double)">
<summary>
 Create a complex number using magnitude/phase polar coordinates
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexExtensions.Complex.Create.Static(System.Double,System.Double)">
<summary>
 Create a complex number x+ij using rectangular coordinates
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexExtensions.Complex.get_i(MathNet.Numerics.Complex)">
<summary>
 The imaginary part of a complex number
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexExtensions.Complex.get_r(MathNet.Numerics.Complex)">
<summary>
 The real part of a complex number
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexExtensions.complex32(System.Single,System.Single)">
<summary>
 Constructs a single precision complex number from both the real and imaginary part.
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexExtensions.complex(System.Double,System.Double)">
<summary>
 Constructs a double precision complex number from both the real and imaginary part.
</summary>
</member>
<member name="T:MathNet.Numerics.ComplexExtensions">

</member>
<member name="M:MathNet.Numerics.ComplexModule.acsch(MathNet.Numerics.Complex)">
<summary>
 Inverse Hyperbolic Cosecant
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.asech(MathNet.Numerics.Complex)">
<summary>
 Inverse Hyperbolic Secant
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.acoth(MathNet.Numerics.Complex)">
<summary>
 Inverse Hyperbolic Cotangent
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.atanh(MathNet.Numerics.Complex)">
<summary>
 Inverse Hyperbolic Tangent
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.acosh(MathNet.Numerics.Complex)">
<summary>
 Inverse Hyperbolic Cosine
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.asinh(MathNet.Numerics.Complex)">
<summary>
 Inverse Hyperbolic Sine
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.csch(MathNet.Numerics.Complex)">
<summary>
 Hyperbolic Cosecant
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.sech(MathNet.Numerics.Complex)">
<summary>
 Hyperbolic Secant
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.coth(MathNet.Numerics.Complex)">
<summary>
 Hyperbolic Cotangent
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.tanh(MathNet.Numerics.Complex)">
<summary>
 Hyperbolic Tangent
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.cosh(MathNet.Numerics.Complex)">
<summary>
 Hyperbolic Cosine
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.sinh(MathNet.Numerics.Complex)">
<summary>
 Hyperbolic Sine
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.acsc(MathNet.Numerics.Complex)">
<summary>
 Arc Cosecant
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.asec(MathNet.Numerics.Complex)">
<summary>
 Arc Secant
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.acot(MathNet.Numerics.Complex)">
<summary>
 Arc Cotangent
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.atan(MathNet.Numerics.Complex)">
<summary>
 Arc Tangent
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.acos(MathNet.Numerics.Complex)">
<summary>
 Arc Cosine
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.asin(MathNet.Numerics.Complex)">
<summary>
 Arc Sine
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.csc(MathNet.Numerics.Complex)">
<summary>
 Cosecant
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.sec(MathNet.Numerics.Complex)">
<summary>
 Secant
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.cot(MathNet.Numerics.Complex)">
<summary>
 Cotangent
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.tan(MathNet.Numerics.Complex)">
<summary>
 Tangent
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.cos(MathNet.Numerics.Complex)">
<summary>
 Cosine
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.sin(MathNet.Numerics.Complex)">
<summary>
 Sine
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.sqrt(MathNet.Numerics.Complex)">
<summary>
 sqrt(x) and 0 &lt;= phase(x) &lt; pi
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.sqr(MathNet.Numerics.Complex)">
<summary>
 sqr(x) is the square (power 2)
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.powf(System.Double,MathNet.Numerics.Complex)">
<summary>
 pow(power,x) is the scalar power
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.pow(MathNet.Numerics.Complex,MathNet.Numerics.Complex)">
<summary>
 pow(power,x) is the complex power
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.log(System.Double,MathNet.Numerics.Complex)">
<summary>
 log(base,x) is log with custom base
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.log10(MathNet.Numerics.Complex)">
<summary>
 log10(x) is common log (base 10)
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.ln(MathNet.Numerics.Complex)">
<summary>
 ln(x) is natural log (base e)
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.exp(MathNet.Numerics.Complex)">
<summary>
 exp(x) = e^x
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.muls(MathNet.Numerics.Complex,System.Double)">
<summary>
 Multiply a complex number by a scalar
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.smul(System.Double,MathNet.Numerics.Complex)">
<summary>
 Multiply a scalar by a complex number
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.div(MathNet.Numerics.Complex,MathNet.Numerics.Complex)">
<summary>
 Complex division of two complex numbers
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.mul(MathNet.Numerics.Complex,MathNet.Numerics.Complex)">
<summary>
 Multiply two complex numbers
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.sub(MathNet.Numerics.Complex,MathNet.Numerics.Complex)">
<summary>
 Subtract one complex number from another
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.add(MathNet.Numerics.Complex,MathNet.Numerics.Complex)">
<summary>
 Add two complex numbers
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.conjugate(MathNet.Numerics.Complex)">
<summary>
 The conjugate of a complex number, i.e. x-yi
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.neg(MathNet.Numerics.Complex)">
<summary>
 Unary negation of a complex number
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.phase(MathNet.Numerics.Complex)">
<summary>
 The polar-coordinate phase of a complex number
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.magnitude(MathNet.Numerics.Complex)">
<summary>
 The polar-coordinate magnitude of a complex number
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.imagPart(MathNet.Numerics.Complex)">
<summary>
 The imaginary part of a complex number
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.realPart(MathNet.Numerics.Complex)">
<summary>
 The real part of a complex number
</summary>
</member>
<member name="P:MathNet.Numerics.ComplexModule.pi">
<summary>
 pi
</summary>
</member>
<member name="P:MathNet.Numerics.ComplexModule.onei">
<summary>
 The complex number 0+1i
</summary>
</member>
<member name="P:MathNet.Numerics.ComplexModule.one">
<summary>
 The complex number 1+0i
</summary>
</member>
<member name="P:MathNet.Numerics.ComplexModule.zero">
<summary>
 The complex number 0+0i
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.ComplexModule.cis(System.Double)">
<summary>
 A complex of magnitude 1 and the given phase and , i.e. cis x = mkPolar 1.0 x
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.mkPolar(System.Double,System.Double)">
<summary>
 Create a complex number using magnitude/phase polar coordinates
</summary>
</member>
<member name="M:MathNet.Numerics.ComplexModule.mkRect(System.Double,System.Double)">
<summary>
 Create a complex number using real and imaginary parts
</summary>
</member>
<member name="T:MathNet.Numerics.ComplexModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:MathNet.Numerics.DifferentiateModule">

</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.zipf(System.Double,System.Int32,System.Random)">
<summary>
 Zipf with s and n parameters.
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.weibull(System.Double,System.Double,System.Random)">
<summary>
 Weibull with shape (k) and scale (λ).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.studentT(System.Double,System.Double,System.Double,System.Random)">
<summary>
 Student-T with location (μ), scale (σ) and degrees of freedom (ν).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.stable(System.Double,System.Double,System.Double,System.Double,System.Random)">
<summary>
 Stable with stability (α), skewness (β), scale (c) and location (μ).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.rayleigh(System.Double,System.Random)">
<summary>
 Rayleigh with scale (σ).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.poisson(System.Double,System.Random)">
<summary>
 Poisson with lambda (λ).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.pareto(System.Double,System.Double,System.Random)">
<summary>
 Pareto with scale (xm) and shape (α).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.standard(System.Random)">
<summary>
 Standard Gaussian.
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.normal(System.Double,System.Double,System.Random)">
<summary>
 Normal with mean (μ) and standard deviation (σ).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.negativeBinomial(System.Double,System.Double,System.Random)">
<summary>
 Negative-Binomial with number of failures (r) until the experiment stopped and probability (p) of a trial resulting in success.
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.logNormal(System.Double,System.Double,System.Random)">
<summary>
 Log-Normal with log-scale (μ) and shape (σ).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.laplace(System.Double,System.Double,System.Random)">
<summary>
 Laplace with location (μ) and scale (b).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.inverseGamma(System.Double,System.Double,System.Random)">
<summary>
 Inverse-Gamma with shape (α) and scale (β)
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.hypergeometric(System.Int32,System.Int32,System.Int32,System.Random)">
<summary>
 Hypergeometric with size of the population (N), number successes within the population (K, M) and number of draws without replacement (n).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.geometric(System.Double,System.Random)">
<summary>
 Geometric with probability (p) of generating one.
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.gamma(System.Double,System.Double,System.Random)">
<summary>
 Gamma with shape (k, α) and rate or inverse scale (β).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.fisherSnedecor(System.Double,System.Double,System.Random)">
<summary>
 Fisher-Snedecor (F-Distribution) with first (d1) and second (d2) degree of freedom.
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.exponential(System.Double,System.Random)">
<summary>
 Exponential with rate (λ).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.erlang(System.Int32,System.Double,System.Random)">
<summary>
 Erlang with shape (k) and rate or inverse scale (λ).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.discreteUniform(System.Int32,System.Int32,System.Random)">
<summary>
 Discrete-Uniform with lower and upper bounds (both inclusive).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.conwayMaxwellPoisson(System.Double,System.Double,System.Random)">
<summary>
 Conway-Maxwell-Poisson with lambda (λ) and rate of decay (ν).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.continuousUniform(System.Double,System.Double,System.Random)">
<summary>
 Continuous-Uniform with lower and upper bounds.
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.chiSquared(System.Double,System.Random)">
<summary>
 Chi-Squared with degrees of freedom (k).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.chi(System.Int32,System.Random)">
<summary>
 Chi with degrees of freedom (k).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.cauchy(System.Double,System.Double,System.Random)">
<summary>
 Cauchy with location (x0) and scale (γ).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.categorical(System.Double[],System.Random)">
<summary>
 Categorical with an array of nonnegative ratios defining the relative probability mass (unnormalized).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.binomial(System.Double,System.Int32,System.Random)">
<summary>
 Binomial with success probability (p) in each trial and number of trials (n).
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.beta(System.Double,System.Double,System.Random)">
<summary>
 Beta with α and β shape parameters.
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Distributions.SampleModule.bernoulli(System.Double,System.Random)">
<summary>
 Bernoulli with probability (p).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:MathNet.Numerics.Distributions.SampleModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:MathNet.Numerics.FindRootsModule">

</member>
<member name="M:MathNet.Numerics.FitModule.linearFunc``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpFunc{``0,System.Double}},``0[],System.Double[])">
<summary>
 Least-Squares fitting the points (x,y) to an arbitrary linear combination y : x -&gt; p0*f0(x) + p1*f1(x) + ... + pk*fk(x),
 returning a function y&apos; for the best fitting combination.
</summary>
</member>
<member name="M:MathNet.Numerics.FitModule.linear``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpFunc{``0,System.Double}},``0[],System.Double[])">
<summary>
 Least-Squares fitting the points (x,y) to an arbitrary linear combination y : x -&gt; p0*f0(x) + p1*f1(x) + ... + pk*fk(x),
 returning its best fitting parameters as [p0, p1, p2, ..., pk] list.
</summary>
</member>
<member name="M:MathNet.Numerics.FitModule.polynomialFunc(System.Int32,System.Double[],System.Double[])">
<summary>
 Least-Squares fitting the points (x,y) to a k-order polynomial y : x -&gt; p0 + p1*x + p2*x^2 + ... + pk*x^k,
 returning a function y&apos; for the best fitting polynomial.
</summary>
</member>
<member name="M:MathNet.Numerics.FitModule.polynomial(System.Int32,System.Double[],System.Double[])">
<summary>
 Least-Squares fitting the points (x,y) to a k-order polynomial y : x -&gt; p0 + p1*x + p2*x^2 + ... + pk*x^k,
 returning its best fitting parameters as [p0, p1, p2, ..., pk] array, compatible with Evaluate.Polynomial.
</summary>
</member>
<member name="M:MathNet.Numerics.FitModule.multiDimFunc(System.Boolean,System.Double[][],System.Double[])">
<summary>
 Least-Squares fitting the points ((x0,x1,...,xk),y) to a linear surface y : X -&gt; p0*x0 + p1*x1 + ... + pk*xk,
 returning a function y&apos; for the best fitting surface.
</summary>
</member>
<member name="M:MathNet.Numerics.FitModule.multiDim(System.Boolean,System.Double[][],System.Double[])">
<summary>
 Least-Squares fitting the points ((x0,x1,...,xk),y) to a linear surface y : X -&gt; p0*x0 + p1*x1 + ... + pk*xk,
 returning its best fitting parameters as [p0, p1, p2, ..., pk] array.
</summary>
</member>
<member name="M:MathNet.Numerics.FitModule.lineFunc(System.Double[],System.Double[])">
<summary>
 Least-Squares fitting the points (x,y) to a line y : x -&gt; a+b*x,
 returning a function y&apos; for the best fitting line.
</summary>
</member>
<member name="M:MathNet.Numerics.FitModule.line(System.Double[],System.Double[])">
<summary>
 Least-Squares fitting the points (x,y) to a line y : x -&gt; a+b*x,
 returning its best fitting parameters as (a, b) tuple.
</summary>
</member>
<member name="">

</member>
<member name="T:MathNet.Numerics.FitModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:MathNet.Numerics.GenerateModule">

</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.stack``1(Microsoft.FSharp.Collections.FSharpList{MathNet.Numerics.LinearAlgebra.Matrix{``0}})">
<summary>
 Create a matrix by stacking a list of matrices vertically, the first matrix on the top.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.append``1(Microsoft.FSharp.Collections.FSharpList{MathNet.Numerics.LinearAlgebra.Matrix{``0}})">
<summary>
 Create a matrix by appending a list of matrices horizontally, the first matrix on the left.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofDiagArray2``1(System.Int32,System.Int32,``0[])">
<summary>
 Create a matrix with the array elements on the diagonal.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofDiagArray``1(``0[])">
<summary>
 Create a square matrix with the array elements on the diagonal.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofDiag2``1(System.Int32,System.Int32,MathNet.Numerics.LinearAlgebra.Vector{``0})">
<summary>
 Create a matrix with the vector elements on the diagonal.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofDiag``1(MathNet.Numerics.LinearAlgebra.Vector{``0})">
<summary>
 Create a square matrix with the vector elements on the diagonal.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofSeqi``2(System.Int32,System.Int32,``0)">
<summary>
 Create a matrix with a given dimension from an indexed sequences of row, column, value tuples.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofListi``1(System.Int32,System.Int32,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Int32,``0}})">
<summary>
 Create a matrix with a given dimension from an indexed list of row, column, value tuples.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofColumnSeq2``2(System.Int32,System.Int32,``0)">
<summary>
 Create a matrix from a list of sequences. Every sequence in the master sequence specifies a column.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofColumnSeq``3(``0)">
<summary>
 Create a matrix from a list of sequences. Every sequence in the master sequence specifies a column.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofColumnList``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Create a matrix from a list of float lists. Every list in the master list specifies a column.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofColumnArrays``1(``0[][])">
<summary>
 Create a matrix from a list of column arrays.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofColumns``1(Microsoft.FSharp.Collections.FSharpList{MathNet.Numerics.LinearAlgebra.Vector{``0}})">
<summary>
 Create a matrix from a list of column vectors.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofRowSeq2``2(System.Int32,System.Int32,``0)">
<summary>
 Create a matrix from a list of sequences. Every sequence in the master sequence specifies a row.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofRowSeq``3(``0)">
<summary>
 Create a matrix from a list of sequences. Every sequence in the master sequence specifies a row.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofRowList``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Create a matrix from a list of float lists. Every list in the master list specifies a row.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofRowArrays``1(``0[][])">
<summary>
 Create a matrix from a list of row arrays.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofRows``1(Microsoft.FSharp.Collections.FSharpList{MathNet.Numerics.LinearAlgebra.Vector{``0}})">
<summary>
 Create a matrix from a list of row vectors.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofMatrixList2``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{MathNet.Numerics.LinearAlgebra.Matrix{``0}}})">
<summary>
 Create a matrix from a list of matrix lists forming a 2D grid.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofMatrixArray2``1(MathNet.Numerics.LinearAlgebra.Matrix{``0}[0:,0:])">
<summary>
 Create a matrix from a 2D array of matrices.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofArray2``1(``0[0:,0:])">
<summary>
 Create a matrix from a 2D array of floating point numbers.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.initDiag``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 Initialize a matrix by calling a construction function for every diagonal element. All other values are zero.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.initColumns``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,MathNet.Numerics.LinearAlgebra.Vector{``0}})">
<summary>
 Initialize a matrix by calling a construction function for every column.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.initRows``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,MathNet.Numerics.LinearAlgebra.Vector{``0}})">
<summary>
 Initialize a matrix by calling a construction function for every row.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.init``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}})">
<summary>
 Initialize a matrix by calling a construction function for every element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.diag2``1(System.Int32,System.Int32,``0)">
<summary>
 Create a matrix with the given dimension and set all diagonal values to x. All other values are zero.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.diag``1(System.Int32,``0)">
<summary>
 Create a matrix with the given dimension and set all diagonal values to x. All other values are zero.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.create``1(System.Int32,System.Int32,``0)">
<summary>
 Create a matrix with the given dimension and set all values to x.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.raw``1(System.Int32,System.Int32,``0[])">
<summary>
 Create a matrix that directly binds to a raw storage array in column-major (column by column) format, without copying.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseMatrixModule.ofStorage``1(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage{``0})">
<summary>
 Create a matrix that directly binds to a storage object.
</summary>
</member>
<member name="T:MathNet.Numerics.LinearAlgebra.DenseMatrixModule">
<summary>
 A module which helps constructing generic dense matrices.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseVectorModule.rangef(System.Double,System.Double,System.Double)">
<summary>
 Create a vector with evenly spaced entries: e.g. rangef -1.0 0.5 1.0 = [-1.0 -0.5 0.0 0.5 1.0]
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseVectorModule.range(System.Int32,System.Int32,System.Int32)">
<summary>
 Create a vector with integer entries in the given range.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseVectorModule.ofSeqi``2(System.Int32,``0)">
<summary>
 Create a vector with a given dimension from an indexed sequences of index, value pairs.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseVectorModule.ofListi``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,``0}})">
<summary>
 Create a vector with a given dimension from an indexed list of index, value pairs.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseVectorModule.ofSeq``2(``0)">
<summary>
 Create a vector from a float sequence.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseVectorModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Create a vector from a float list.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseVectorModule.ofArray``1(``0[])">
<summary>
 Create a vector from a float array (by copying - use raw instead if no copy is needed).
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseVectorModule.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 Initialize a vector by calling a construction function for every element.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseVectorModule.create``1(System.Int32,``0)">
<summary>
 Initialize an x-valued vector with the given dimension.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseVectorModule.raw``1(``0[])">
<summary>
 Create a vector that directly binds to a raw storage array, without copying.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DenseVectorModule.ofStorage``1(MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage{``0})">
<summary>
 Create a vector that directly binds to a storage object.
</summary>
</member>
<member name="T:MathNet.Numerics.LinearAlgebra.DenseVectorModule">
<summary>
 A module which helps constructing generic dense vectors.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DiagonalMatrixModule.ofDiagArray2``1(System.Int32,System.Int32,``0[])">
<summary>
 Create a matrix with the array elements on the diagonal.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DiagonalMatrixModule.ofDiagArray``1(``0[])">
<summary>
 Create a square matrix with the array elements on the diagonal.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DiagonalMatrixModule.ofDiag2``1(System.Int32,System.Int32,MathNet.Numerics.LinearAlgebra.Vector{``0})">
<summary>
 Create a matrix with the vector elements on the diagonal.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DiagonalMatrixModule.ofDiag``1(MathNet.Numerics.LinearAlgebra.Vector{``0})">
<summary>
 Create a square matrix with the vector elements on the diagonal.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DiagonalMatrixModule.init2``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 Initialize a matrix by calling a construction function for every element.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DiagonalMatrixModule.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 Initialize a square matrix by calling a construction function for every element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DiagonalMatrixModule.create2``1(System.Int32,System.Int32,``0)">
<summary>
 Create a matrix with the given dimension and set all diagonal values to x.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DiagonalMatrixModule.create``1(System.Int32,``0)">
<summary>
 Create a square matrix with the given order and set all diagonal values to x.
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DiagonalMatrixModule.raw2``1(System.Int32,System.Int32,``0[])">
<summary>
 Create a matrix that directly binds to a raw storage array that represents the diagonal, without copying.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DiagonalMatrixModule.raw``1(``0[])">
<summary>
 Create a square matrix that directly binds to a raw storage array that represents the diagonal, without copying.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.DiagonalMatrixModule.ofStorage``1(MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage{``0})">
<summary>
 Create a matrix that directly binds to a storage object.
</summary>
</member>
<member name="T:MathNet.Numerics.LinearAlgebra.DiagonalMatrixModule">
<summary>
 A module which helps constructing generic diagonal matrices.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixExtensions.Matrix`1.SetSlice``1(MathNet.Numerics.LinearAlgebra.Matrix{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32,MathNet.Numerics.LinearAlgebra.Vector{``0})">
<summary>
 Sets a column subvector using a specified row index and column range.
 This method can be used via the x.[r1 .. r2, c] &lt;- v syntax (F#3.1)
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixExtensions.Matrix`1.SetSlice``1(MathNet.Numerics.LinearAlgebra.Matrix{``0},System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},MathNet.Numerics.LinearAlgebra.Vector{``0})">
<summary>
 Sets a row subvector using a specified row index and column range.
 This method can be used via the x.[r, c1 .. c2] &lt;- v syntax (F#3.1)
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixExtensions.Matrix`1.GetSlice``1(MathNet.Numerics.LinearAlgebra.Matrix{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.Int32)">
<summary>
 Gets a column subvector using a specified row index and column range.
 This method can be used via the x.[r1 .. r2, c] syntax (F#3.1)
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixExtensions.Matrix`1.GetSlice``1(MathNet.Numerics.LinearAlgebra.Matrix{``0},System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Gets a row subvector using a specified row index and column range.
 This method can be used via the x.[r, c1 .. c2] syntax (F#3.1)
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixExtensions.Matrix`1.SetSlice``1(MathNet.Numerics.LinearAlgebra.Matrix{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},MathNet.Numerics.LinearAlgebra.Matrix{``0})">
<summary>
 Sets a submatrix using a specified column range and
 row range (all indices are optional)
 This method can be used via the x.[r1 .. r2, c1 .. c2 ] &lt;- m syntax
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixExtensions.Matrix`1.GetSlice``1(MathNet.Numerics.LinearAlgebra.Matrix{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Gets a submatrix using a specified column range and
 row range (all indices are optional)
 This method can be used via the x.[r1 .. r2, c1 .. c2 ] syntax
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixExtensions.matrix``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Construct a dense matrix from a nested list of numbers.
</summary>
</member>
<member name="T:MathNet.Numerics.LinearAlgebra.MatrixExtensions">
<summary>
 Module that contains implementation of useful F#-specific extension members for generic matrices
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.sumRowsBy``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},``1}},``2)">
<summary>
 Returns the sum of the results generated by applying a position dependent function to each row of the matrix.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.sumColsBy``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},``1}},``2)">
<summary>
 Returns the sum of the results generated by applying a position dependent function to each column of the matrix.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.sum``2(``0)">
<summary>
 Returns the sum of all elements of a matrix.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.subInPlace``3(``0,``2)">
<summary>
 In place matrix subtraction.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.addInPlace``3(``0,``2)">
<summary>
 In-place matrix addition.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.foldByRow``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0,``1)">
<summary>
 Fold all rows into one column vector.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.foldByCol``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0,``1)">
<summary>
 Fold all columns into one row vector.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.inplaceAssign``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}},``1)">
<summary>
 In-place assignment.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.foldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1,``2)">
<summary>
 Fold a function over all matrix elements in reverse order.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.foldRow``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,``2,System.Int32)">
<summary>
 Fold one row.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.foldCol``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,``2,System.Int32)">
<summary>
 Fold one column.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.mapRows``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},MathNet.Numerics.LinearAlgebra.Vector{``0}}},``1)">
<summary>
 Map every matrix row using the given position dependent function.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.mapCols``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},MathNet.Numerics.LinearAlgebra.Vector{``0}}},``1)">
<summary>
 Map every matrix column using the given position dependent function.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.mapiSkipZeros``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}}},``2)">
<summary>
 Map every matrix element using the given position dependent function.
 Zero-values may be skipped (relevant mostly for sparse matrices).
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.mapi``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}}},``2)">
<summary>
 Map every matrix element using the given position dependent function.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.mapSkipZeros``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Map every matrix element using the given function.
 Zero-values may be skipped (relevant mostly for sparse matrices).
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Map every matrix element using the given function.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.mapRowsInPlace``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},MathNet.Numerics.LinearAlgebra.Vector{``0}}},``1)">
<summary>
 In-place map every matrix row using the given position dependent function.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.mapColsInPlace``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},MathNet.Numerics.LinearAlgebra.Vector{``0}}},``1)">
<summary>
 In-place map every matrix column using the given position dependent function.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.mapiSkipZerosInPlace``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},``1)">
<summary>
 In-place map of every matrix element using a position dependent function.
 Zero-values may be skipped (relevant mostly for sparse matrices).
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.mapiInPlace``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},``1)">
<summary>
 In-place map of every matrix element using a position dependent function.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.mapSkipZerosInPlace``2(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``1)">
<summary>
 In-place map of every matrix element using a function.
 Zero-values may be skipped (relevant mostly for sparse matrices).
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.mapInPlace``2(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``1)">
<summary>
 In-place map of every matrix element using a function.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.foralliRows``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},System.Boolean}},``1)">
<summary>
 Checks whether all rows in the matrix that satisfy a position dependent predicate.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.forallRows``2(Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},System.Boolean},``1)">
<summary>
 Checks whether all rows in the matrix that satisfy a predicate.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.foralliCols``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},System.Boolean}},``1)">
<summary>
 Checks whether all columns in the matrix that satisfy a position dependent predicate.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.forallCols``2(Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},System.Boolean},``1)">
<summary>
 Checks whether all columns in the matrix that satisfy a predicate.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.foralliSkipZeros``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}}},``1)">
<summary>
 Checks whether all non-zero entries in the matrix that satisfies a given position dependent predicate. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.forallSkipZeros``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
<summary>
 Checks whether all non-zero entries in the matrix that satisfies a given predicate. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.foralli``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}}},``1)">
<summary>
 Checks whether all entries in the matrix that satisfies a given position dependent predicate.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.forall``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
<summary>
 Checks whether all entries in the matrix that satisfies a given predicate.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.existsiRow``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},System.Boolean}},``1)">
<summary>
 Checks whether there is a row in the matrix that satisfies a position dependent predicate.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.existsRow``2(Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},System.Boolean},``1)">
<summary>
 Checks whether there is a row in the matrix that satisfies a predicate.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.existsiCol``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},System.Boolean}},``1)">
<summary>
 Checks whether there is a column in the matrix that satisfies a position dependent predicate.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.existsCol``2(Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},System.Boolean},``1)">
<summary>
 Checks whether there is a column in the matrix that satisfies a predicate.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.existsiSkipZeros``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}}},``1)">
<summary>
 Checks whether there is a non-zero entry in the matrix that satisfies a position dependent predicate. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.existsSkipZeros``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
<summary>
 Checks whether there is a non-zero entry in the matrix that satisfies a predicate. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.existsi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}}},``1)">
<summary>
 Checks whether there is an entry in the matrix that satisfies a position dependent predicate.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.exists``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
<summary>
 Checks whether there is an entry in the matrix that satisfies a predicate.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.reduceRows``2(Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},MathNet.Numerics.LinearAlgebra.Vector{``0}}},``1)">
<summary>
 Reduce all rows of a matrix.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.reduceCols``2(Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},MathNet.Numerics.LinearAlgebra.Vector{``0}}},``1)">
<summary>
 Reduce all columns of a matrix.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.reduceSkipZeros``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``1)">
<summary>
 Reduce all non-zero entries of a matrix. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.reduce``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``1)">
<summary>
 Reduce all entries of a matrix.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.scaniRows``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``1},``0}}},``0,``2)">
<summary>
 Scan all rows of a matrix with an indexed folding function.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.scanRows``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``1},``0}},``0,``2)">
<summary>
 Scan all rows of a matrix.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.scaniCols``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``1},``0}}},``0,``2)">
<summary>
 Scan all columns of a matrix with an indexed folding function.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.scanCols``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``1},``0}},``0,``2)">
<summary>
 Scan all columns of a matrix.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.scaniSkipZeros``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}}},``0,``2)">
<summary>
 Scan all non-zero entries of a matrix with an indexed folding function. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.scanSkipZeros``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,``2)">
<summary>
 Scan all non-zero entries of a matrix. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.scani``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}}},``0,``2)">
<summary>
 Scan all entries of a matrix with an indexed folding function.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.scan``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,``2)">
<summary>
 Scan all entries of a matrix.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.foldiRows``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``1},``0}}},``0,``2)">
<summary>
 Fold all rows of a matrix with an indexed folding function.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.foldRows``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``1},``0}},``0,``2)">
<summary>
 Fold all rows of a matrix.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.foldiCols``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``1},``0}}},``0,``2)">
<summary>
 Fold all columns of a matrix with an indexed folding function.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.foldCols``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``1},``0}},``0,``2)">
<summary>
 Fold all columns of a matrix.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.foldiSkipZeros``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}}},``0,``2)">
<summary>
 Fold all non-zero entries of a matrix with an indexed folding function. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.foldSkipZeros``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,``2)">
<summary>
 Fold all non-zero entries of a matrix. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.foldi``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}}},``0,``2)">
<summary>
 Fold all entries of a matrix with an indexed folding function.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,``2)">
<summary>
 Fold all entries of a matrix.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.iteriRows``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},Microsoft.FSharp.Core.Unit}},``1)">
<summary>
 Applies a function to all indexed rows of the matrix.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.iterRows``2(Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},Microsoft.FSharp.Core.Unit},``1)">
<summary>
 Applies a function to all rows of the matrix.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.iteriCols``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},Microsoft.FSharp.Core.Unit}},``1)">
<summary>
 Applies a function to all indexed columns of the matrix.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.iterCols``2(Microsoft.FSharp.Core.FSharpFunc{MathNet.Numerics.LinearAlgebra.Vector{``0},Microsoft.FSharp.Core.Unit},``1)">
<summary>
 Applies a function to all columns of the matrix.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.iteriSkipZeros``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}}},``1)">
<summary>
 Applies a function to all non-zero indexed elements of the matrix. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.iterSkipZerosnz``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``1)">
<summary>
 Applies a function to all non-zero elements of the matrix. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.iteri``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}}},``1)">
<summary>
 Applies a function to all indexed elements of the matrix.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.iter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``1)">
<summary>
 Applies a function to all elements of the matrix.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.toRowSeqi``2(``0)">
<summary>
 Transform a matrix into an indexed row sequence.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.toRowSeq``2(``0)">
<summary>
 Transform a matrix into a row sequence.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.toColSeqi``2(``0)">
<summary>
 Transform a matrix into an indexed column sequence.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.toColSeq``2(``0)">
<summary>
 Transform a matrix into a column sequence.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.toSeqiSkipZeros``2(``0)">
<summary>
 Transform a matrix into an indexed sequence where zero-values are skipped. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.toSeqSkipZeros``2(``0)">
<summary>
 Transform a matrix into a sequence where zero-values are skipped. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.toSeqi``2(``0)">
<summary>
 Transform a matrix into an indexed sequence.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.toSeq``2(``0)">
<summary>
 Transform a matrix into a sequence.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.toRowArrays``2(``0)">
<summary>
 Transform a matrix into an array of row arrays.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.toColArrays``2(``0)">
<summary>
 Transform a matrix into an array of column arrays.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.MatrixModule.toArray2``2(``0)">
<summary>
 Transform a matrix into a 2D array.
</summary>
</member>
<member name="T:MathNet.Numerics.LinearAlgebra.MatrixModule">
<summary>
 A module which implements functional matrix operations.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.stack``1(Microsoft.FSharp.Collections.FSharpList{MathNet.Numerics.LinearAlgebra.Matrix{``0}})">
<summary>
 Create a matrix by stacking a list of matrices vertically, the first matrix on the top.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.append``1(Microsoft.FSharp.Collections.FSharpList{MathNet.Numerics.LinearAlgebra.Matrix{``0}})">
<summary>
 Create a matrix by appending a list of matrices horizontally, the first matrix on the left.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofDiagArray2``1(System.Int32,System.Int32,``0[])">
<summary>
 Create a matrix with the array elements on the diagonal.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofDiagArray``1(``0[])">
<summary>
 Create a square matrix with the array elements on the diagonal.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofDiag2``1(System.Int32,System.Int32,MathNet.Numerics.LinearAlgebra.Vector{``0})">
<summary>
 Create a matrix with the vector elements on the diagonal.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofDiag``1(MathNet.Numerics.LinearAlgebra.Vector{``0})">
<summary>
 Create a square matrix with the vector elements on the diagonal.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofSeqi``2(System.Int32,System.Int32,``0)">
<summary>
 Create a matrix with a given dimension from an indexed sequences of row, column, value tuples.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofListi``1(System.Int32,System.Int32,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Int32,``0}})">
<summary>
 Create a matrix with a given dimension from an indexed list of row, column, value tuples.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofColumnSeq2``2(System.Int32,System.Int32,``0)">
<summary>
 Create a matrix from a list of sequences. Every sequence in the master sequence specifies a column.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofColumnSeq``3(``0)">
<summary>
 Create a matrix from a list of sequences. Every sequence in the master sequence specifies a column.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofColumnList``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Create a matrix from a list of float lists. Every list in the master list specifies a column.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofColumnArrays``1(``0[][])">
<summary>
 Create a matrix from a list of column arrays.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofColumns``1(Microsoft.FSharp.Collections.FSharpList{MathNet.Numerics.LinearAlgebra.Vector{``0}})">
<summary>
 Create a matrix from a list of column vectors.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofRowSeq2``2(System.Int32,System.Int32,``0)">
<summary>
 Create a matrix from a list of sequences. Every sequence in the master sequence specifies a row.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofRowSeq``3(``0)">
<summary>
 Create a matrix from a list of sequences. Every sequence in the master sequence specifies a row.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofRowList``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Create a matrix from a list of float lists. Every list in the master list specifies a row.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofRowArrays``1(``0[][])">
<summary>
 Create a matrix from a list of row arrays.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofRows``1(Microsoft.FSharp.Collections.FSharpList{MathNet.Numerics.LinearAlgebra.Vector{``0}})">
<summary>
 Create a matrix from a list of row vectors.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofMatrixList2``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{MathNet.Numerics.LinearAlgebra.Matrix{``0}}})">
<summary>
 Create a matrix from a list of matrix lists forming a 2D grid.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofMatrixArray2``1(MathNet.Numerics.LinearAlgebra.Matrix{``0}[0:,0:])">
<summary>
 Create a matrix from a 2D array of matrices.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofArray2``1(``0[0:,0:])">
<summary>
 Create a matrix from a 2D array of floating point numbers.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.initDiag``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 Initialize a matrix by calling a construction function for every diagonal element. All other values are zero.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.initColumns``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,MathNet.Numerics.LinearAlgebra.Vector{``0}})">
<summary>
 Initialize a matrix by calling a construction function for every column.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.initRows``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,MathNet.Numerics.LinearAlgebra.Vector{``0}})">
<summary>
 Initialize a matrix by calling a construction function for every row.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.init``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}})">
<summary>
 Initialize a matrix by calling a construction function for every element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.diag2``1(System.Int32,System.Int32,``0)">
<summary>
 Create a matrix with the given dimension and set all diagonal values to x. All other values are zero.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.diag``1(System.Int32,``0)">
<summary>
 Create a matrix with the given dimension and set all diagonal values to x. All other values are zero.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.create``1(System.Int32,System.Int32,``0)">
<summary>
 Create a matrix with the given dimension and set all values to x. Note that a dense matrix would likely be more appropriate.
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseMatrixModule.ofStorage``1(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage{``0})">
<summary>
 Create a matrix that directly binds to a storage object.
</summary>
</member>
<member name="T:MathNet.Numerics.LinearAlgebra.SparseMatrixModule">
<summary>
 A module which helps constructing generic sparse matrices.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseVectorModule.ofSeqi``2(System.Int32,``0)">
<summary>
 Create a sparse vector with a given dimension from an indexed sequence of index, value pairs.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseVectorModule.ofListi``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,``0}})">
<summary>
 Create a sparse vector with a given dimension from an indexed list of index, value pairs.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseVectorModule.ofSeq``2(``0)">
<summary>
 Create a sparse vector from a float sequence.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseVectorModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Create a sparse vector from a float list.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseVectorModule.ofArray``1(``0[])">
<summary>
 Create a sparse vector from a float array.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseVectorModule.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 Initialize a vector by calling a construction function for every element.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseVectorModule.create``1(System.Int32,``0)">
<summary>
 Initialize an x-valued vector with the given dimension.
</summary>
</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.LinearAlgebra.SparseVectorModule.ofStorage``1(MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage{``0})">
<summary>
 Create a vector that directly binds to a storage object.
</summary>
</member>
<member name="T:MathNet.Numerics.LinearAlgebra.SparseVectorModule">
<summary>
 A module which helps constructing generic sparse vectors.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorExtensions.Vector`1.SetSlice``1(MathNet.Numerics.LinearAlgebra.Vector{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},MathNet.Numerics.LinearAlgebra.Vector{``0})">
<summary>
 Sets a slice of a vector starting at a specified index
 and ending at a specified index (both indices are optional)
 This method can be used via the x.[start .. finish] &lt;- v syntax
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorExtensions.Vector`1.GetSlice``1(MathNet.Numerics.LinearAlgebra.Vector{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Gets a slice of a vector starting at a specified index
 and ending at a specified index (both indices are optional)
 This method can be used via the x.[start .. finish] syntax
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorExtensions.vector``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Construct a dense vector from a list of floating point numbers.
</summary>
</member>
<member name="T:MathNet.Numerics.LinearAlgebra.VectorExtensions">
<summary>
 Module that contains implementation of useful F#-specific extension members for generic vectors
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.subInPlace``3(``0,``2)">
<summary>
 In place vector subtraction.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.addInPlace``3(``0,``2)">
<summary>
 In-place vector addition.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.insert``2(System.Int32,``0,``1)">
<summary>
 Creates a new vector and inserts the given value at the given index.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.scanBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1,``2)">
<summary>
 Scans a vector in reverse order; like foldBack but returns the intermediate result.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.reduceBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``1)">
<summary>
 Reduces a vector in reverse order: the result of this function will be f(v[1], ..., f(v[n-2], f(v[n-1],v[n]))...).
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.foldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1,``2)">
<summary>
 Fold all entries of a vector in reverse order.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.fold2SkipZeros``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,``3,``4)">
<summary>
 Folds two vectors by applying a function to update the status for each element pair.
 Zero-Zero value-pairs may be skipped (relevant mostly for sparse vectors).
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.fold2``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,``3,``4)">
<summary>
 Folds two vectors by applying a function to update the status for each element pair.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.map2SkipZeros``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``1,``2)">
<summary>
 Maps two vectors to a new vector by applying a function to every element pair.
 Zero-Zero value-pairs may be skipped (relevant mostly for sparse vectors).
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``1,``2)">
<summary>
 Maps two vectors to a new vector by applying a function to every element pair.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.mapiSkipZeros``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``2)">
<summary>
 Maps a vector to a new vector by applying a function to every element.
 Zero-values may be skipped (relevant mostly for sparse vectors).
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.mapi``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``2)">
<summary>
 Maps a vector to a new vector by applying a function to every element.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.mapSkipZeros``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Maps a vector to a new vector by applying a function to every element.
 Zero-values may be skipped (relevant mostly for sparse vectors).
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2)">
<summary>
 Maps a vector to a new vector by applying a function to every element.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.mapiSkipZerosInPlace``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``1)">
<summary>
 In-place mutation by applying a function to every element of the vector.
 Zero-values may be skipped (relevant mostly for sparse vectors).
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.mapSkipZerosInPlace``2(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``1)">
<summary>
 In-place mutation by applying a function to every element of the vector.
 Zero-values may be skipped (relevant mostly for sparse vectors).
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.mapiInPlace``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``1)">
<summary>
 In-place mutation by applying a function to every element of the vector.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.mapInPlace``2(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``1)">
<summary>
 In-place mutation by applying a function to every element of the vector.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.foralliSkipZeros``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},``1)">
<summary>
 Checks whether all non-zero entries in the vector that satisfies a given position dependent predicate. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.forallSkipZeros``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
<summary>
 Checks whether all non-zero entries in the vector that satisfies a given predicate. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.foralli``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},``1)">
<summary>
 Checks whether all entries in the vector that satisfies a given position dependent predicate.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.forall``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
<summary>
 Checks whether all entries in the vector that satisfies a given predicate.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.existsiSkipZeros``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},``1)">
<summary>
 Checks whether there is a non-zero entry in the vector that satisfies a position dependent predicate. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.existsSkipZeros``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
<summary>
 Checks whether there is a non-zero entry in the vector that satisfies a predicate. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.existsi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},``1)">
<summary>
 Checks whether there is an entry in the vector that satisfies a position dependent predicate.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.exists``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``1)">
<summary>
 Checks whether there is an entry in the vector that satisfies a predicate.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.reduceSkipZeros``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``1)">
<summary>
 Reduce all non-zero entries of a vector. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.reduce``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``1)">
<summary>
 Reduce all entries of a vector.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.scaniSkipZeros``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,``2)">
<summary>
 Scan all non-zero entries of a vector using a position dependent folding function. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.scanSkipZeros``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,``2)">
<summary>
 Scan all non-zero entries of a vector. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.scani``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,``2)">
<summary>
 Scan all entries of a vector using a position dependent folding function.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.scan``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,``2)">
<summary>
 Scan all entries of a vector.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.foldiSkipZeros``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,``2)">
<summary>
 Fold all non-zero entries of a vector using a position dependent folding function. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.foldSkipZeros``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,``2)">
<summary>
 Fold all non-zero entries of a vector. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.foldi``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,``2)">
<summary>
 Fold all entries of a vector using a position dependent folding function.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,``2)">
<summary>
 Fold all entries of a vector.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.iteriSkipZeros``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},``1)">
<summary>
 Applies a function to all non-zero indexed elements of the vector. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.iterSkipZeros``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``1)">
<summary>
 Applies a function to all non-zero elements of the vector. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.iteri``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},``1)">
<summary>
 Applies a function to all indexed elements of the vector.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.iter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``1)">
<summary>
 Applies a function to all elements of the vector.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.toSeqiSkipZeros``2(``0)">
<summary>
 Transform a vector into an indexed sequence where zero-values are skipped. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.toSeqSkipZeros``2(``0)">
<summary>
 Transform a vector into a sequence where zero-values are skipped. Skipping zeros is efficient on sparse data.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.toSeqi``2(``0)">
<summary>
 Transform a vector into an indexed sequence.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.toSeq``2(``0)">
<summary>
 Transform a vector into a sequence.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.toList``2(``0)">
<summary>
 Transform a vector into a list.
</summary>
</member>
<member name="M:MathNet.Numerics.LinearAlgebra.VectorModule.toArray``2(``0)">
<summary>
 Transform a vector into an array.
</summary>
</member>
<member name="T:MathNet.Numerics.LinearAlgebra.VectorModule">
<summary>
 A module which implements functional vector operations.
</summary>
</member>
<member name="T:MathNet.Numerics.Probability">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Random.RandomModule.mrg32k3a">
<summary>
 Creates a 32-bit combined multiple recursive generator with 2 components of order 3 pRNG with a robust seed
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Random.RandomModule.mcg31m1">
<summary>
 Creates a Multiplicative congruential generator using a modulus of 2^31-1 and a multiplier of 1132489760 pRNG with a robust seed
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Random.RandomModule.mcg59">
<summary>
 Creates a Multiplicative congruential generator using a modulus of 2^59 and a multiplier of 13^13 pRNG with a robust seed
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Random.RandomModule.palf">
<summary>
 Creates a Parallel Additive Lagged Fibonacci pRNG with a robust seed
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Random.RandomModule.wh2006">
<summary>
 Creates a Wichmann-Hill’s 2006 combined multiplicative congruential pRNG with a robust seed
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Random.RandomModule.wh1982">
<summary>
 Creates a Wichmann-Hill’s 1982 combined multiplicative congruential pRNG with a robust seed
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Random.RandomModule.xorshift">
<summary>
 Creates a multiply-with-carry Xorshift (Xn = a * Xn−3 + c mod 2^32) pRNG with a robust seed
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:MathNet.Numerics.Random.RandomModule.mersenneTwisterShared">
<summary>
 Creates a Mersenne Twister 19937 pRNG with a robust seed
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Random.RandomModule.crypto">
<summary>
 Creates a default .Net cryptographic system pRNG
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:MathNet.Numerics.Random.RandomModule.systemShared">
<summary>
 Creates a default .Net system pRNG with a robust seed
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:MathNet.Numerics.Random.RandomModule.doubles(System.Int32)">
<summary>
 Default sampling, efficient but without custom seed (uses robust seeds internally)
</summary>
</member>
<member name="P:MathNet.Numerics.Random.RandomModule.shared">
<summary>
 Returns the default random source, thread-safe and also thread-locally shared
</summary>
</member>
<member name="T:MathNet.Numerics.Random.RandomModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:MathNet.Numerics.Statistics.StatisticsModule">

</member>
</members>
</doc>
